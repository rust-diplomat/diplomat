// generated by diplomat-tool

import { OptionStruct } from "./OptionStruct.mjs"
import wasm from "./diplomat-wasm.mjs";
import * as diplomatRuntime from "./diplomat-runtime.mjs";




const OptionOpaque_box_destroy_registry = new FinalizationRegistry((ptr) => {
    wasm.OptionOpaque_destroy(ptr);
});

export class OptionOpaque {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];
    
    
    _fromFFI(ptr, selfEdge) {
        
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;
        // Unconditionally register to destroy when this object is ready to garbage collect.
        OptionOpaque_box_destroy_registry.register(this, this.#ptr);
    }
    constructor() {
        throw new Error("You cannot create the opaque type OptionOpaque without a valid constructor. You may call one of the static methods below, or you may label the default opaque constructor in the diplomat FFI definition with #[diplomat::attr(constructor)].");
    }

    get ffiValue() {
        return this.#ptr;
    }


    static new_(i) {
        const result = wasm.OptionOpaque_new(i);
    
        try {
    
            return ((result == 0) ? undefined : OptionOpaque._fromFFI(result, []));
        } finally {
        
        }
    }

    static newNone() {
        const result = wasm.OptionOpaque_new_none();
    
        try {
    
            return ((result == 0) ? undefined : OptionOpaque._fromFFI(result, []));
        } finally {
        
        }
    }

    static returns() {
        
        const diplomat_receive_buffer = wasm.diplomat_alloc(17, 4);
        const result = wasm.OptionOpaque_returns(diplomat_receive_buffer);
    
        try {
    
            if (!diplomatRuntime.resultFlag(wasm, diplomat_receive_buffer, 16)) {
                throw diplomatRuntime.FFIError(null);
            }
            return OptionStruct._fromFFI(diplomat_receive_buffer);
        } finally {
        
            wasm.diplomat_free(diplomat_receive_buffer, 17, 4);
        
        }
    }

    static newStruct() {
        
        const diplomat_receive_buffer = wasm.diplomat_alloc(16, 4);
        const result = wasm.OptionOpaque_new_struct(diplomat_receive_buffer);
    
        try {
    
            return OptionStruct._fromFFI(diplomat_receive_buffer);
        } finally {
        
            wasm.diplomat_free(diplomat_receive_buffer, 16, 4);
        
        }
    }

    static newStructNones() {
        
        const diplomat_receive_buffer = wasm.diplomat_alloc(16, 4);
        const result = wasm.OptionOpaque_new_struct_nones(diplomat_receive_buffer);
    
        try {
    
            return OptionStruct._fromFFI(diplomat_receive_buffer);
        } finally {
        
            wasm.diplomat_free(diplomat_receive_buffer, 16, 4);
        
        }
    }

    assertInteger(i) {
        wasm.OptionOpaque_assert_integer(this.ffiValue, i);
    
        try {
    
        } finally {
        
        }
    }

    static optionOpaqueArgument(arg) {
        const result = wasm.OptionOpaque_option_opaque_argument(arg.ffiValue ?? 0);
    
        try {
    
            return result;
        } finally {
        
        }
    }

    

}