// generated by diplomat-tool

part of 'lib.g.dart';

final class _BorrowedFieldsFfi extends ffi.Struct {
  external _SliceUtf16 a;
  external _SliceUtf8 b;
  external _SliceUtf8 c;
}

final class BorrowedFields {
  String a;
  String b;
  String c;
  // ignore: unused_field
  final core.List<Object> _edgeX;

  BorrowedFields({required this.a, required this.b, required this.c}) : _edgeX = [];

  // Internal constructor from FFI.
  // This struct contains borrowed fields, so this takes in a list of
  // "edges" corresponding to where each lifetime's data may have been borrowed from
  // and passes it down to individual fields containing the borrow.
  // This method does not attempt to handle any dependencies between lifetimes, the caller
  // should handle this when constructing edge arrays.
  // ignore: unused_element
  BorrowedFields._(_BorrowedFieldsFfi underlying, {required core.List<Object> edgeX}) :
    _edgeX = edgeX,
    a = core.String.fromCharCodes(underlying.a._pointer.asTypedList(underlying.a._length)),
    b = Utf8Decoder().convert(underlying.b._pointer.asTypedList(underlying.b._length)),
    c = Utf8Decoder().convert(underlying.c._pointer.asTypedList(underlying.c._length));

  // ignore: unused_element
  _BorrowedFieldsFfi _toFfi(ffi.Allocator temp) {
    final struct = ffi.Struct.create<_BorrowedFieldsFfi>();
    final aView = a.utf16View;
    struct.a._pointer = aView.toFfi(temp);
    struct.a._length = aView.length;
    final bView = b.utf8View;
    struct.b._pointer = bView.toFfi(temp);
    struct.b._length = bView.length;
    final cView = c.utf8View;
    struct.c._pointer = cView.toFfi(temp);
    struct.c._length = cView.length;
    return struct;
  }

  @override
  bool operator ==(Object other) =>
      other is BorrowedFields &&
      other.a == this.a &&
      other.b == this.b &&
      other.c == this.c;

  @override
  int get hashCode => Object.hashAll([
        this.a,
        this.b,
        this.c,
      ]);
}
