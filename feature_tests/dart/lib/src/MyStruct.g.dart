// generated by diplomat-tool

// https://github.com/dart-lang/sdk/issues/53946
// ignore_for_file: non_native_function_type_argument_to_pointer

part of 'lib.g.dart';

final class _MyStructFfi extends ffi.Struct {
  @ffi.Uint8()
  external int a;
  @ffi.Bool()
  external bool b;
  @ffi.Uint8()
  external int c;
  @ffi.Uint64()
  external int d;
  @ffi.Int32()
  external int e;
  @ffi.Uint32()
  external Rune f;
  @ffi.Int32()
  external int g;
}

final class MyStruct {
  final _MyStructFfi _underlying;

  MyStruct._(this._underlying);

  int get a => _underlying.a;
  set a(int a) {
    _underlying.a = a;
  }

  bool get b => _underlying.b;
  set b(bool b) {
    _underlying.b = b;
  }

  int get c => _underlying.c;
  set c(int c) {
    _underlying.c = c;
  }

  int get d => _underlying.d;
  set d(int d) {
    _underlying.d = d;
  }

  int get e => _underlying.e;
  set e(int e) {
    _underlying.e = e;
  }

  Rune get f => _underlying.f;
  set f(Rune f) {
    _underlying.f = f;
  }

  MyEnum get g => MyEnum.values.firstWhere((v) => v._underlying == _underlying.g);
  set g(MyEnum g) {
    _underlying.g = g._underlying;
  }

  factory MyStruct() {
    final result = _MyStruct_new();
    return MyStruct._(result);
  }

  // ignore: non_constant_identifier_names
  static final _MyStruct_new =
    _capi<ffi.NativeFunction<_MyStructFfi Function()>>('MyStruct_new')
      .asFunction<_MyStructFfi Function()>(isLeaf: true);

  int intoA() {
    final result = _MyStruct_into_a(_underlying);
    return result;
  }

  // ignore: non_constant_identifier_names
  static final _MyStruct_into_a =
    _capi<ffi.NativeFunction<ffi.Uint8 Function(_MyStructFfi)>>('MyStruct_into_a')
      .asFunction<int Function(_MyStructFfi)>(isLeaf: true);

  @override
  bool operator ==(Object other) =>
      other is MyStruct &&
      other._underlying.a == _underlying.a &&
      other._underlying.b == _underlying.b &&
      other._underlying.c == _underlying.c &&
      other._underlying.d == _underlying.d &&
      other._underlying.e == _underlying.e &&
      other._underlying.f == _underlying.f &&
      other._underlying.g == _underlying.g;

  @override
  int get hashCode => Object.hashAll([
        _underlying.a,
        _underlying.b,
        _underlying.c,
        _underlying.d,
        _underlying.e,
        _underlying.f,
        _underlying.g,
      ]);
}
