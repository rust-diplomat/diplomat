---
source: macro/src/lib.rs
expression: "rustfmt_code(&gen_bridge(parse_quote! {\n                            mod ffi\n                            {\n                                struct Foo<'a>\n                                {\n                                    a: &'a [u8], b: &'a [u16], c: &'a str, d: &'a DiplomatStr,\n                                    e: &'a DiplomatStr16, f: &'a [DiplomatByte],\n                                } impl Foo\n                                {\n                                    pub fn\n                                    make(a: &'a [u8], b: &'a [u16], c: &'a str, d: &'a\n                                    DiplomatStr, e: &'a DiplomatStr16, f: &'a [DiplomatByte]) ->\n                                    Self { Foo { a, b, c, d, e, f, } } pub fn\n                                    boxes(a: Box<[u8]>, b: Box<[u16]>, c: Box<str>, d:\n                                    Box<DiplomatStr>, e: Box<DiplomatStr16>, f:\n                                    Box<[DiplomatByte]>) -> Self { unimplemented!() } pub fn\n                                    a(self) -> &[u8] { self.a } pub fn b(self) -> &[u16]\n                                    { self.b } pub fn c(self) -> &str { self.c } pub fn d(self)\n                                    -> &DiplomatStr { self.d } pub fn e(self) -> &DiplomatStr16\n                                    { self.e } pub fn f(self) -> &[DiplomatByte] { self.f }\n                                }\n                            }\n                        }).to_token_stream().to_string())"
---
mod ffi {
    #[repr(C)]
    #[derive(Clone, Copy)]
    struct Foo<'a> {
        a: &'a [u8],
        b: &'a [u16],
        c: &'a str,
        d: &'a DiplomatStr,
        e: &'a DiplomatStr16,
        f: &'a [DiplomatByte],
    }
    impl Foo {
        pub fn make(
            a: &'a [u8],
            b: &'a [u16],
            c: &'a str,
            d: &'a DiplomatStr,
            e: &'a DiplomatStr16,
            f: &'a [DiplomatByte],
        ) -> Self {
            Foo { a, b, c, d, e, f }
        }
        pub fn boxes(
            a: Box<[u8]>,
            b: Box<[u16]>,
            c: Box<str>,
            d: Box<DiplomatStr>,
            e: Box<DiplomatStr16>,
            f: Box<[DiplomatByte]>,
        ) -> Self {
            unimplemented!()
        }
        pub fn a(self) -> &[u8] {
            self.a
        }
        pub fn b(self) -> &[u16] {
            self.b
        }
        pub fn c(self) -> &str {
            self.c
        }
        pub fn d(self) -> &DiplomatStr {
            self.d
        }
        pub fn e(self) -> &DiplomatStr16 {
            self.e
        }
        pub fn f(self) -> &[DiplomatByte] {
            self.f
        }
    }
    use diplomat_runtime::*;
    #[no_mangle]
    extern "C" fn Foo_make(
        a: diplomat_runtime::DiplomatSlice<u8>,
        b: diplomat_runtime::DiplomatSlice<u16>,
        c: diplomat_runtime::DiplomatUTF8StrSlice,
        d: diplomat_runtime::DiplomatStrSlice,
        e: diplomat_runtime::DiplomatStr16Slice,
        f: diplomat_runtime::DiplomatSlice<DiplomatByte>,
    ) -> Foo {
        let a = a.into();
        let b = b.into();
        let c = c.into();
        let d = d.into();
        let e = e.into();
        let f = f.into();
        Foo::make(a, b, c, d, e, f)
    }
    #[no_mangle]
    extern "C" fn Foo_boxes(
        a: diplomat_runtime::DiplomatOwnedSlice<u8>,
        b: diplomat_runtime::DiplomatOwnedSlice<u16>,
        c: diplomat_runtime::DiplomatOwnedUTF8StrSlice,
        d: diplomat_runtime::DiplomatOwnedStrSlice,
        e: diplomat_runtime::DiplomatOwnedStr16Slice,
        f: diplomat_runtime::DiplomatOwnedSlice<DiplomatByte>,
    ) -> Foo {
        let a = a.into();
        let b = b.into();
        let c = c.into();
        let d = d.into();
        let e = e.into();
        let f = f.into();
        Foo::boxes(a, b, c, d, e, f)
    }
    #[no_mangle]
    extern "C" fn Foo_a(this: Foo) -> &[u8] {
        this.a()
    }
    #[no_mangle]
    extern "C" fn Foo_b(this: Foo) -> &[u16] {
        this.b()
    }
    #[no_mangle]
    extern "C" fn Foo_c(this: Foo) -> &str {
        this.c()
    }
    #[no_mangle]
    extern "C" fn Foo_d(this: Foo) -> &DiplomatStr {
        this.d()
    }
    #[no_mangle]
    extern "C" fn Foo_e(this: Foo) -> &DiplomatStr16 {
        this.e()
    }
    #[no_mangle]
    extern "C" fn Foo_f(this: Foo) -> &[DiplomatByte] {
        this.f()
    }
}
