<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Diplomat Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Diplomat Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/rust-diplomat/diplomat">Diplomat</a> is a framework and tool for generating bindings to Rust libraries from an extensible set of languages.</p>
<p>Diplomat is for <em>unidirectional</em> bindings: it's for when foreign code wishes to call into a Rust library, but not vice versa. If you're looking for bidirectional bindings, tools like <a href="https://github.com/dtolnay/cxx">cxx</a> are a good bet.</p>
<p>Diplomat is a proc macro paired with a tool. The proc macro is capable of generating an <code>extern "C"</code> binding layer around tagged Rust code, while the tool is able to generate corresponding C, C++, JS, or <code>&lt;insert language here&gt;</code> that philosophically matches the API on the Rust side. This means that methods in Rust map to "methods" in the target language, <code>Result</code> in Rust map to tagged unions in C++ and exceptions in Javascript, etc. These all work through the generated C API, however they preserve higher level API features which C cannot express.</p>
<h2 id="a-note-on-the-design"><a class="header" href="#a-note-on-the-design">A note on the design</a></h2>
<p>You can read the full design doc <a href="https://github.com/rust-diplomat/diplomat/blob/main/docs/design_doc.md">here</a>.</p>
<p>Diplomat does not do cross-crate global analysis, it restricts its view to specially tagged modules, and only generates bindings based on information found in those modules. This means that changing some struct in some dependency will not magically affect your generated C++/JS/etc APIs; all such change can only come from deliberate change to these tagged modules. This also means that Diplomat can cleanly define a subset of Rust used for declaring the exported API without impacting the flavor of Rust used in dependencies. One can imagine <code>#[diplomat::bridge]</code> blocks to almost be a DSL for bridging between your Rust APIs and a more general API shape that can be translated cleanly across languages.</p>
<p>Diplomat is designed such that it should not be a large amount of effort to <a href="developer.html">write new language targets for Diplomat</a>.</p>
<h2 id="backends-supported"><a class="header" href="#backends-supported">Backends supported</a></h2>
<p>Diplomat currently supports the following backends:</p>
<ul>
<li>C</li>
<li>C++</li>
<li>JavaScript/TypeScript (using WASM)
<ul>
<li><a href="./demo_gen/intro.html">demo_gen</a></li>
</ul>
</li>
<li>Dart</li>
<li>Kotlin (using JNA)</li>
<li>Python via <a href="https://github.com/wjakob/nanobind">Nanobind</a> (maintained by <a href="https://www.zeromatter.com/">Zeromatter</a>)</li>
</ul>
<p>There is work in progress for a <a href="https://github.com/rust-diplomat/diplomat/issues/144">Java backend</a> (using Panama). We used to have a .NET backend but it was removed in a refactor, it may get added again.</p>
<p>We're happy to fix bugs or add configurability in the current backends if their produced output does not match what you need in your language. Details on how to write new backends is documented <a href="developer.html">later in this book</a>: you can do so as a third party library depending on <code>diplomat_core</code>, but we are also happy to accept these into Diplomat with the understanding that we'll only do minimal work to keep them working over time.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>To install the <code>diplomat</code> CLI tool, run</p>
<pre><code class="language-shell">$ cargo install diplomat-tool
</code></pre>
<p>Let's say this installs <code>diplomat-tool 0.10.0</code></p>
<p>You can then add <code>diplomat</code> as a dependency to your project like so:</p>
<pre><code class="language-toml">diplomat = "0.10.0"
diplomat-runtime = "0.10.0"
</code></pre>
<p>It is recommended to create a separate crate for the FFI interface. Diplomat will only read the contents of specially tagged modules so it is possible to mix Diplomat code with normal Rust code, but it is prefereable to minimize this since proc macros can make debugging hard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>To install the <code>diplomat</code> CLI tool, run</p>
<pre><code class="language-shell">$ cargo install diplomat-tool
</code></pre>
<p>Let's say this installs <code>diplomat-tool 0.10.0</code></p>
<p>You can then add <code>diplomat</code> as a dependency to your project like so:</p>
<pre><code class="language-toml">diplomat = "0.10.0"
diplomat-runtime = "0.10.0"
</code></pre>
<p>It is recommended to create a separate crate for the FFI interface. Diplomat will only read the contents of specially tagged modules so it is possible to mix Diplomat code with normal Rust code, but it is prefereable to minimize this since proc macros can make debugging hard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>When using Diplomat, you'll need to define Rust modules that contain the Rust APIs you want to expose. You can do this by using the <code>diplomat::bridge</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    pub struct MyFFIStruct {
        pub a: i32,
        pub b: bool,
    }
    
    impl MyFFIStruct {
        pub fn create() -&gt; MyFFIStruct {
            MyFFIStruct {
                a: 42,
                b: true
            }
        }

        pub fn do_a_thing(self) {
            println!("doing thing {:?}", self.b);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is a simple struct with public fields; which is easier to reason about in an introductory example. <em>Most</em> APIs exposed via Diplomat will be via "opaque types", to be covered in the <a href="./opaque.html">chapter on opaque types</a>.</p>
<p>Every type declared within a <code>diplomat::bridge</code> module along with all methods in its associated impl will be exposed over FFI. For example, the above code will generate the following extern API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern "C" fn MyFFIStruct_create() -&gt; MyFFIStruct {
    MyFFIStruct::create()
}

#[no_mangle]
extern "C" fn MyFFIStruct_do_a_thing(this: &amp;MyFFIStruct) {
    this.do_a_thing()
}
<span class="boring">}</span></code></pre></pre>
<p>We can then generate the bindings for this API using the <code>diplomat-tool</code> CLI.</p>
<h2 id="c"><a class="header" href="#c">C++</a></h2>
<p>For example, if we want to generate C++ bindings, we can create a folder `cpp/`` and generate bindings in it by running:</p>
<pre><code class="language-shell">$ diplomat-tool cpp cpp/
</code></pre>
<p>This will generate the following struct in <code>MyFFIStruct.hpp</code>, along with some boilerplate:</p>
<pre><code class="language-cpp">struct MyFFIStruct {
 public:
  int32_t a;
  bool b;
  static MyFFIStruct create();
  void do_a_thing();
};
</code></pre>
<p>If we want to generate Sphinx documentation to cpp-docs, we can run with that as an additional parameter:</p>
<pre><code class="language-shell">$ diplomat-tool cpp cpp/ --docs cpp-docs/
</code></pre>
<h2 id="wasm"><a class="header" href="#wasm">WASM</a></h2>
<p>For WASM JS/TypeScript bindings, you can use the following options, with similarly named directories:</p>
<pre><code class="language-shell">$ diplomat-tool js js/ --docs js/docs/
</code></pre>
<p>This will generate JS that has a <code>MyFFIStruct</code> class, with a static <code>create()</code> method, a <code>do_a_thing()</code> method, and getters for the fields. This JS will require there to be a <code>wasm.mjs</code> file that loads in the built wasm file (See <a href="https://github.com/rust-diplomat/diplomat/issues/80">issue #80</a> for improving this), which you can base off of <a href="https://github.com/rust-diplomat/diplomat/blob/38cffa9bc2ef21d0aba89ed7d76236de4153248a/example/js/wasm.mjs">this file</a>.</p>
<h2 id="c-1"><a class="header" href="#c-1">C</a></h2>
<p>While low-level C headers are generated in the process of running <code>diplomat-tool cpp</code>, you can also generate just the C headers with</p>
<pre><code class="language-shell">$ diplomat-tool c c/
</code></pre>
<p>Note that Diplomat's C mode generates direct bindings to the lower level <code>extern "C"</code> API, and is not idiomatic C code. It is recommended that one build a higher level API around the C API (perhaps by writing a plugin) if C bindings are desired.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-diplomat"><a class="header" href="#configuring-diplomat">Configuring Diplomat</a></h1>
<p>Some Diplomat backends have configurable parameters to change the behavior of their output.</p>
<p>For instance, Kotlin requires a <code>domain</code> parameter and <code>lib_name</code> parameter. These two parameters are used to generate a package name and folder structure on generation.</p>
<h2 id="configuration-structures"><a class="header" href="#configuration-structures">Configuration Structures</a></h2>
<p>Documentation on what configuration options are available in <a href="https://github.com/rust-diplomat/diplomat/tree/main/tool/src/config.rs"><code>config.rs</code> on GitHub</a>.</p>
<p>Note that every configuration option uses <code>snake_case</code> for consistency, and that the <code>SharedConfig</code> struct is flattened. So for setting <code>--config shared_config.lib_name="some_value"</code>, this would instead be <code>--config lib_name="some_value"</code>.</p>
<h2 id="configuration-interfaces"><a class="header" href="#configuration-interfaces">Configuration Interfaces</a></h2>
<p>Configuration information can be set in four ways:</p>
<h3 id="configtoml"><a class="header" href="#configtoml"><code>config.toml</code></a></h3>
<p>By default, Diplomat scans for a <code>config.toml</code> in the folder where <code>diplomat_tool</code> is being run. You can change the location of this folder with the <code>--config_file</code> parameter.</p>
<p>The structure of <code>config.toml</code> is as follows:</p>
<pre><code class="language-toml"># Top level table specifies Shared Config settings that apply to all backends:
lib-name = "MyLibrary"

[kotlin]
# Individual tables can override Shared Config settings:
lib-name = "LibraryNameOverride"
# Along with backend specific settings:
domain = "org.myOrganization"

[demo_gen]
explicit-generation = true

[other-library-name]
some-value = 100
</code></pre>
<h3 id="diplomat-tool-cli"><a class="header" href="#diplomat-tool-cli"><code>diplomat-tool</code> CLI</a></h3>
<p>When running <code>diplomat-tool</code>, you may pass in the <code>--config</code> flag for each option you wish to set:</p>
<pre><code>./diplomat-tool kotlin ./kotlin-folder --config lib_name="MyLibrary" --config kotlin.domain = "org.myOrganization"
</code></pre>
<p><code>diplomat-tool</code> flags take priority over <code>config.toml</code>.</p>
<h3 id="diplomat_toolgen"><a class="header" href="#diplomat_toolgen"><code>diplomat_tool::gen</code></a></h3>
<p>If you call <code>diplomat_tool::gen</code> manually, then you have the option of setting configuration yourself, with the <code>diplomat_tool::config::Config</code> struct.</p>
<p>See <a href="config.html#backend-structures">Backend Structures</a> for more on these structures.</p>
<h3 id="diplomatconfig"><a class="header" href="#diplomatconfig"><code>#[diplomat::config(...)]</code></a></h3>
<p>In <code>lib.rs</code>, any top-level <code>mod</code>ule, <code>struct</code>, or <code>impl</code> block can use the <code>#[diplomat::config]</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::config(lib_name="MyLibrary")]
struct SomeConfig;

#[diplomat::config(kotlin.domain="org.myOrganization")]
mod kotlin_specific_mod;

#[diplomat::config(...)]
impl SomeConfig {

}
<span class="boring">}</span></code></pre></pre>
<p>Due to a quirk of how Diplomat reads these attributes, <code>#[diplomat::config]</code> has priority over all other methods of setting configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Diplomat only supports a small set of types that can be passed over FFI.</p>
<ul>
<li>Builtins:
<ul>
<li>All integers</li>
<li><code>bool</code></li>
<li><code>char</code></li>
<li><code>DiplomatChar</code> (<code>u32</code>), which is treated as <code>char</code>-equivalent on the backend language, but need not be a valid Unicode code point for the Rust code to be sound.</li>
<li>Slices, <code>&amp;[T]</code> where <code>T</code> is one of:
<ul>
<li>An integer type</li>
<li><code>bool</code></li>
<li><code>char</code></li>
<li><code>DiplomatByte</code> (<code>u8</code>): The same as <code>u8</code> except in languages where "byte buffer" and "list of integers" are different types</li>
<li><code>Box&lt;OpaqueType&gt;</code></li>
<li><code>DiplomatStrSlice</code>: An array of unvalidated strings, expected to be UTF-8. Currently only supported in C/C++ backends</li>
</ul>
</li>
<li>String slices:
<ul>
<li><code>&amp;str</code>: A validated, UTF-8 string. Will be converted/validated by the target language bindings if necessary.</li>
<li><code>&amp;DiplomatStr</code>: An unvalidated string expected to be UTF-8.</li>
<li><code>&amp;DiplomatStr16</code>: An unvalidated string expected to be UTF-16.</li>
</ul>
</li>
<li><a href="./writeable.html"><code>DiplomatWriteable</code></a> for returning strings. This needs to be the last parameter of the method.</li>
<li><a href="./option.html"><code>Option&lt;&amp;T&gt;</code> ,<code>Option&lt;Box&lt;T&gt;&gt;</code></a> of opaque types, <code>Option&lt;T&gt;</code> of structs, enums, primitives, or the above slice types</li>
<li><a href="./callbacks.html">Callbacks</a> in parameters. Support is limited.</li>
<li><code>Result&lt;T, E&gt;</code> in return values</li>
<li><code>()</code> as a <code>Result</code> <code>Ok</code>/<code>Error</code> type, or as a return value</li>
</ul>
</li>
<li>Custom types
<ul>
<li>Custom <a href="./opaque.html">opaque types</a> (passed as references or via <code>Box&lt;T&gt;</code>)</li>
<li>Custom <a href="./structs.html">structs and C-like enums</a></li>
</ul>
</li>
</ul>
<p>More types can be supported in the future (We have an issue open for <a href="https://github.com/rust-diplomat/diplomat/pull/621">traits</a>)</p>
<p>The <em>main</em> distinction to keep track of is between "opaque types" and "structs": opaque types are for when you want to wrap a Rust object that has its own semantics, whereas "structs" are for when you want to transparently pass around multiple values at once (usually when you want to make an options struct as an argument, or return multiple values at once).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opaque-types"><a class="header" href="#opaque-types">Opaque Types</a></h1>
<p>In the vast majority of cases, we'd like to expose Rust types over FFI "opaquely", that is, the FFI code does not know anything about the contents of these types, rather it wants to do things with the type.</p>
<p>By default, Diplomat will not let you expose fields of types other than the <a href="./types.html">allowed types</a> over FFI. The following code will trigger a resolution error when running <code>diplomat-tool</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    pub struct MyFFIType {
        pub a: i32,
        pub b: Vec&lt;String&gt;, // or "SomeTypeDefinedElsewhere"
    }
    
    impl MyFFIType {
        pub fn create() -&gt; MyFFIType {
            todo!()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Of course, if Diplomat is to be able to usefully expose Rust APIs without requiring everything be defined within Diplomat's bridge blocks, there has to be some way to include them in this the API.</p>
<p>For this in Diplomat we declare <em>opaque types</em>, which can only exist behind pointers. Such types can contain whatever they want, but they can never be passed over the stack through FFI, and the other side cannot peek into them in ways other than calling explicitly defined methods.</p>
<p>For example, say we have the following type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyCollection {
    name: String,
    items: Vec&lt;String&gt;,
}

impl MyCollection {
    pub fn new(name: String) -&gt; Self {
        Self {
            name, items: vec![]
        }
    }

    pub fn push(&amp;mut self, s: String) {
        self.items.push(s)
    }

    pub fn dump(&amp;self) {
        println!("Collection {} with items {:?}", self.name, self.items);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To expose it over FFI, we'd do something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    // import this from wherever, does not need
    // to be the same crate
    use super::MyCollection as RustCollection;

    #[diplomat::opaque]
    pub struct MyCollection(RustCollection);

    impl MyCollection {
        pub fn create(s: &amp;str) -&gt; Box&lt;MyCollection&gt; {
            Box::new(MyCollection(RustCollection::new(s.into())))
        }

        pub fn push(&amp;mut self, s: &amp;str) {
            self.0.push(s.into())
        }

        pub fn dump(&amp;self) {
            self.0.dump()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This will generate code exposing <code>create()</code>, <code>push()</code>, and <code>dump()</code> over FFI, as well as glue to ensure the destructor is called. However this will not expose any way to get at the <code>RustCollection</code>.</p>
<p>For example, the generated C++ looks something like</p>
<pre><code class="language-cpp">class MyCollection {
 public:
  static std::unique_ptr&lt;MyCollection&gt; create(const std::string_view s);
  void push(const std::string_view s);
  void dump();
  // snip
 private:
};
</code></pre>
<p>When exposing your library over FFI, most of the main types will probably end up being "opaque".</p>
<h1 id="boxes-are-return-only"><a class="header" href="#boxes-are-return-only">Boxes are return-only</a></h1>
<p><code>Box&lt;T&gt;</code> can only be returned, not accepted as a parameter. This is because in garbage collected languages it is not possible to know if we are the unique owner when converting back to Rust. There are some techniques we could use to add such functionality, see <a href="https://github.com/rust-diplomat/diplomat/issues/317">#317</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and enums</a></h1>
<p>Diplomat allows for exposing basic structs and enums over FFI. Typically these should be used as inputs and outputs to other methods, rather than having methods of their own, however it is possible to give them methods which capture <code>self</code> by-value.</p>
<p>Structs are most commonly found when making an options type for a method, or when doing multiple return values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    use my_thingy::MyThingy;

    // just exists so we can get methods
    #[diplomat::opaque]
    pub struct Thingy(MyThingy);

    pub struct ThingySettings {
        pub a: bool,
        pub b: u8,
        pub speed: SpeedSetting,
    }

    #[diplomat::enum_convert(my_thingy::SpeedSetting)]
    pub enum SpeedSetting {
        Fast, Medium, Slow
    }

    #[diplomat::enum_convert(my_thingy::ThingyStatus)]
    pub enum ThingyStatus {
        Good,
        Bad
    }

    impl Thingy {
        pub fn create(settings: ThingySettings) -&gt; Box&lt;Thingy&gt; {
            // Convert our FFI type to whatever internal settings type was needed
            let settings = my_thingy::ThingySettings {
                a: settings.a,
                b: settings.b,
                speed: settings.speed.into()
            };
            Box::new(Thingy::new(settings))
        }

        pub fn get_status(&amp;self) -&gt; ThingyStatus {
            self.0.get_status().into()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Enums exposed via Diplomat must be simple C-like enums. They can have explicit discriminants. Structs may only contain fields which are themselves <a href="./types.html">allowed types</a>.</p>
<p>In C++ the structs are translated to simple structs and the enums become simple enum classes. In JS the structs become objects with fields, and the enums are exposed as strings that get converted at the boundary.</p>
<h1 id="diplomatenum_convert"><a class="header" href="#diplomatenum_convert"><code>diplomat::enum_convert</code></a></h1>
<p>Diplomat can autogenerate <code>Into</code> impls to an enum from your library using <code>#[diplomat::enum_convert]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    // ...

    #[diplomat::enum_convert(my_thingy::SpeedSetting)]
    enum SpeedSetting {
        Fast, Medium, Slow
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>In case the enum is <code>#[non_exhaustive]</code>, you may need to supply a <code>needs_wildcard</code> argument, like so: <code>#[diplomat::enum_convert(my_library::SpeedSetting, needs_wildcard)]</code>.</p>
<h1 id="structs-containing-boxes"><a class="header" href="#structs-containing-boxes">Structs containing boxes</a></h1>
<p>By default, structs cannot contain output-only types like <code>Box&lt;T&gt;</code>. This can be opted in to by using <code>#[diplomat::out]</code>, which will have the additional effect of making the struct an output-only type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod ffi {
    use my_thingy::MyThingy;

    #[diplomat::opaque]
    pub struct Thingy(=MyThingy);

    #[diplomat::out]
    pub struct ThingyAndExtraStuff {
        pub thingy: Box&lt;Thingy&gt;,
        pub stuff: u32
    }

    impl Thingy {
        pub fn create() -&gt; ThingyAndExtraStuff {
            let thingy = Box::new(Thingy(MyThingy::new()));
            let stuff = 42;
            ThingyAndExtraStuff {
                thingy, stuff
            }
        }
    }

}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-types"><a class="header" href="#option-types">Option types</a></h1>
<p>Option types in Diplomat are relatively straightforward, you simply use <code>Option&lt;T&gt;</code> and it turns into the idiomatic equivalent over FFI.</p>
<p><code>Option&lt;T&gt;</code> currently only works when wrapping reference types (<code>Box&lt;OpaqueType&gt;</code> and <code>&amp;OpaqueType</code>), structs/enums/primitives, or slices of the above. It may be used as an input argument, or in return type position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    // just exists so we can get methods
    #[diplomat::opaque]
    pub struct Thingy;

    impl Thingy {
        pub fn maybe_create() -&gt; Option&lt;Box&lt;Thingy&gt;&gt; {
            Some(Box::new(Thingy))
        }

        pub fn increment_option(x: Option&lt;u8&gt;) -&gt; Option&lt;u8&gt; {
            x.map(|inner| inner + 1)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In C++ <code>maybe_create</code> will return a <code>std::optional&lt;std::unique_ptr&lt;Thingy&gt;&gt;</code>, and in JS it will return a potentially-null object.</p>
<p><code>make_option</code> will have similar behavior, returning <code>std::optional&lt;uint8_t&gt;</code> and an integer-or-null in JS. It will accept <code>std::optional&lt;uint8_t&gt;</code> in C++ and null-check the parameter in JS.</p>
<h2 id="diplomatoption"><a class="header" href="#diplomatoption">DiplomatOption</a></h2>
<p><code>Option&lt;T&gt;</code> is FFI-safe for reference types but not for other arbitrary types. When used in function parameters, Diplomat will automatically use FFI-safe types over the boundary, however with structs layout concerns prevent automatically doing this. Instead, if you wish to use an <code>Option&lt;T&gt;</code> in a struct (for struct, enum, or primitive <code>T</code>), use <code>DiplomatOption&lt;T&gt;</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    use diplomat_runtime::DiplomatOption;

    #[diplomat::opaque]
    pub struct MyOpaque(u8);

    pub enum MyEnum {
        Foo, Bar
    }

    pub struct MyStruct&lt;'a&gt; {
        a: DiplomatOption&lt;u8&gt;,
        b: DiplomatOption&lt;MyEnum&gt;,
        c: Option&lt;&amp;'a MyOpaque&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-types"><a class="header" href="#result-types">Result types</a></h1>
<p>Result types are returned by using <a href="https://docs.rs/diplomat-runtime/0.2.0/diplomat_runtime/struct.DiplomatResult.html"><code>Result&lt;T, E&gt;</code></a> (or <code>DiplomatResult&lt;T, E&gt;</code>).</p>
<p>For example, let's say we wish to define a fallible constructor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct Thingy(u8);

    impl Thingy {
        pub fn try_create(string: &amp;str) -&gt; Result&lt;Box&lt;Thingy&gt;, ()&gt; {
            let parsed: Result&lt;u8, ()&gt; = string.parse().map_err(|_| ());
            parsed.map(Thingy).map(Box::new)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>On the C++ side, this will generate a method on <code>Thingy</code> with the signature</p>
<pre><code class="language-cpp">  static diplomat::result&lt;std::unique_ptr&lt;Thingy&gt;, std::monostate&gt; try_create(const std::string_view string);
</code></pre>
<p><code>diplomat::result</code> is a type that can be found in the generated <a href="https://github.com/rust-diplomat/diplomat/blob/main/tool/src/cpp/runtime.hpp"><code>diplomat_runtime.hpp</code></a> file. The most basic APIs are <code>.is_ok()</code> and <code>.is_err()</code>, returning <code>bool</code>s, and <code>.ok()</code> and <code>.err()</code> returning <code>std::option</code>s. There are further APIs for constructing and manipulating these that can be found in the header file.</p>
<p>On the JS side it will continue to return the <code>Thingy</code> class but it will <code>throw</code> the error (as an empty object in this case) in case of an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-strings-writeables"><a class="header" href="#returning-strings-writeables">Returning strings: Writeables</a></h1>
<p>Most languages have their own type to handle strings. To avoid unnecessary allocations, Diplomat supports <a href="https://docs.rs/diplomat-runtime/0.2.0/diplomat_runtime/struct.DiplomatWriteable.html"><code>DiplomatWriteable</code></a>, a type with a <code>Write</code> implementation which can be used to write to appropriate string types on the other side.</p>
<p>For example, if we want to have methods that philosophically return a <code>String</code> or a <code>Result&lt;String&gt;</code>, we can do the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    use diplomat_runtime::DiplomatWriteable;
    use std::fmt::Write;

    #[diplomat::opaque]
    #[derive(Debug)]
    pub struct Thingy(u8);

    impl Thingy {
        pub fn debug_output(&amp;self, writeable: &amp;mut DiplomatWriteable) {
            write!(writeable, "{:?}", self);
        }

        pub fn maybe_get_string(&amp;self, writeable: &amp;mut DiplomatWriteable) -&gt; Result&lt;(), ()&gt; {
            write!(writeable, "integer is {}", self.0).map_err(|_| ())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>On the JS side these will get converted to APIs that return strings (<code>maybe_get_string</code> will potentially throw in the case of an error, as is usual with <code>DiplomatResult</code>)</p>
<p>In C++ these become APIs that return <code>std::string</code> and <code>diplomat::result&lt;std::string, std::monostate&gt;</code> respectively.</p>
<p>Essentially, versions of the API returning <code>std::string</code> are generated, where the <code>write!()</code> operation will end up writing <em>directly to the <code>std::string</code></em> with no additional intermediate Rust <code>String</code> allocations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<p>Some Diplomat backends support <code>--docs</code>, which will generate additional documentation from your Markdown doc comments</p>
<pre><code class="language-shell">$ diplomat-tool cpp cpp/ --docs cpp-docs/
</code></pre>
<p>The C++ and JS backends generate Sphinx docs. If using TypeScript, the definition files will automatically come with <code>tsdoc</code>-compatible doc comments.</p>
<p>A limited amount of intra-doc-links are supported: it is possible to link to custom <em>types</em> (but not methods or variants) using <code>[`FooBar`]</code> syntax, like Rust.</p>
<p>Furthermore, you can use <code>#[diplomat::rust_link(path::to::rust::type, Struct)]</code> to autogenerate links for to published docs, which typically show up as a "For more information see &lt;link&gt;" at the bottom of the docs for the given item. Since Diplomat cannot do resolution on other crates, it relies on the <code>rust_link</code> annotation to provide the kind of Rust item or doc page being linked to. An additional <code>compact</code> parameter can be passed in case you wish to provide multiple <code>rust_link</code>s that are to be collapsed into a single "For more information see 1, 2, 3" line.</p>
<p>Put together, this might look something like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    use my_thingy::MyThingy;

    /// A Thingy
    #[diplomat::rust_link(my_thingy::MyThingy, Struct)]
    #[diplomat::opaque]
    pub struct Thingy(MyThingy);

    #[diplomat::enum_convert(my_thingy::SpeedSetting)]
    #[diplomat::rust_link(my_thingy::SpeedSetting, Enum)]
    pub enum SpeedSetting {
        Fast, Medium, Slow
    }

    #[diplomat::enum_convert(my_thingy::ThingyStatus)]
    #[diplomat::rust_link(my_thingy::ThingyStatus, Enum)]
    pub enum ThingyStatus {
        Good,
        Bad
    }

    impl Thingy {
        /// Make a [`MyThingy`]!
        #[diplomat::rust_link(my_thingy::MyThingy::new, FnInStruct)]
        pub fn create(speed: SpeedSetting) -&gt; Box&lt;Thingy&gt; {
            Box::new(Thingy(Thingy::new(speed.into())))
        }

        /// Get the status
        #[diplomat::rust_link(my_thingy::MyThingy::get_status, FnInStruct)]
        pub fn get_status(&amp;self) -&gt; ThingyStatus {
            self.0.get_status().into()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The full list of item kinds recognized by <code>rust_link</code> is:</p>
<ul>
<li><code>Struct</code></li>
<li><code>StructField</code></li>
<li><code>Enum</code></li>
<li><code>EnumVariant</code></li>
<li><code>EnumVariantField</code></li>
<li><code>Trait</code></li>
<li><code>FnInStruct</code></li>
<li><code>FnInEnum</code></li>
<li><code>FnInTrait</code></li>
<li><code>DefaultFnInTrait</code></li>
<li><code>Fn</code></li>
<li><code>Mod</code></li>
<li><code>Constant</code></li>
<li><code>AssociatedConstantInEnum</code></li>
<li><code>AssociatedConstantInTrait</code></li>
<li><code>AssociatedConstantInStruct</code></li>
<li><code>Macro</code></li>
<li><code>AssociatedTypeInEnum</code></li>
<li><code>AssociatedTypeInTrait</code></li>
<li><code>AssociatedTypeInStruct</code></li>
<li><code>Typedef</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>Diplomat <em>is</em> able to safely handle methods that do complex borrowing, as long as the lifetimes are fully specified (i.e., not elided).</p>
<p>In general, Diplomat attempts to follow language norms when it comes to patterns akin to borrowing. In C++, for example, the norm is to document the behavior of a method, which is what Diplomat does. However, in JS, the norm is to not have use-after-frees, which Diplomat attempts to achieve by stashing extra references to borrowed-from objects.</p>
<p>For example, let's take this iterator API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {

    #[diplomat::opaque]
    pub struct MyFancyVec(Vec&lt;u32&gt;); // not very fancy

    pub struct MyFancyIterator&lt;'a&gt;(std::slice::Iter&lt;'a, u32&gt;);


    impl MyFancyVec {
        pub fn new(count: usize) -&gt; Box&lt;MyFancyVec&gt; {
            // make a random vector, this is an example
            let vec = (5..(count + 5)).collect();
            Box::new(MyFancyVec(vec));
        }

        pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Box&lt;MyFancyIterator&lt;'a&gt;&gt; {
            Box::new(MyFancyIterator(self.0.iter()))
        }
    }

    impl&lt;'a&gt; MyFancyIterator&lt;'a&gt; {
        fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
            self.0.next().copied()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It's crucial the return type of <code>MyFancyVec::iter()</code> is not held on to longer than the <code>MyFancyVec</code> it came from.</p>
<p>In C++, this will produce documentation that looks like the following:</p>
<pre><code>Lifetimes: `self` must live at least as long as the output.
</code></pre>
<p>On the other hand, in JS, the JS object wrapping <code>MyFancyIterator</code> will internally stash a reference to the <code>MyFancyVec</code>, which will be noticed by the GC, keeping the vector alive as long as needed.</p>
<p>This also works with non-opaque structs; you can have a function that takes in a struct where one field has a lifetime, and returns a different struct with a similar property, and Diplomat will document or GC-link the appropriate fields.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abi-namingrenaming"><a class="header" href="#abi-namingrenaming">ABI naming/renaming</a></h1>
<p>As previously mentioned, the <code>#[diplomat::bridge]</code> macro from the <code>diplomat</code> crate will generate <code>extern "C"</code> functions for all methods expected to be exposed over FFI.</p>
<p><em>By default</em>, the naming scheme for these types is <code>TypeName_method()</code>. For example, <code>Foo::bar()</code> becomes <code>Foo_bar()</code>.</p>
<p>However, these names can be changed, both at an individual and bulk level, using the <code>#[diplomat::abi_rename = "..."]</code> attribute.</p>
<p>One use case for this is maintaining ABI stability. Let's say you wished to change the signature or even behavior of <code>Foo::bar()</code> to go from returning a <code>u8</code> to returning a <code>u16</code>, and were okay with requiring new bindings for the new behavior, but wanted to ensure that old headers/bindings would still work against new Rust code without any change. You could do that by</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {

    #[diplomat::opaque]
    struct Foo;

    impl Foo {
        #[diplomat::abi_rename = "Foo_bar"]
        pub fn old_bar(&amp;self) -&gt; u8 {}

        #[diplomat::abi_rename = "Foo_bar2"]
        pub fn bar(&amp;self) -&gt; u16 {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>old_bar()</code> is still exposed over FFI as <code>Foo_bar()</code>, whereas the new <code>bar()</code> method is exposed as <code>Foo_bar2()</code>.</p>
<p>However, from the point of view of higher-level bindings generated over this (e.g. in C++ or JS), <code>Foo</code> now has a <code>bar()</code> method with a new signature, and an <code>old_bar()</code> method with the signature <code>bar()</code> used to have.</p>
<p>The attribute can be applied directly on methods, but it can also be applied on impl blocks, types, and even entire bridge modules. It supports using replacement patterns, so it can be used for namespacing the generated FFI functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
#[diplomat::abi_rename = "mylibrary_{}"]
mod ffi {

    #[diplomat::opaque]
    struct Foo;

    impl Foo {
        pub fn bar() -&gt; u8 {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, instead of the function being generated as <code>Foo_bar()</code>, it will be generated as <code>mylibrary_Foo_bar()</code> which is a more unique symbol, less likely to cause trouble for the linker.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customizing-via-backend-attributes"><a class="header" href="#customizing-via-backend-attributes">Customizing via backend attributes</a></h1>
<p>Diplomat supports a number of "backend attributes" that allow one to customize the backend-side code generation of a particular API. This allows for more expressivity than that afforded by Diplomat's relatively constrained type system, including things like the ability to rename types, namespace types, or mark types as iterators.</p>
<h2 id="configurability"><a class="header" href="#configurability">Configurability</a></h2>
<p>All backend attributes are applied via the <code>#[diplomat::attr(...)]</code> directive. As its first parameter, it requires a configuration specification, which can be:</p>
<ul>
<li><code>*</code>, meaning "all backends"</li>
<li><code>auto</code>, explained below</li>
<li>A backend/language name: (<code>c</code>, <code>cpp</code>, <code>js</code>, <code>dart</code>, <code>kotlin</code>, <code>demo</code>, ...). Note that a backend may accept multiple names, for example the <code>demo</code> backend both accepts attributes marked for the <code>js</code> and <code>demo</code> backends.</li>
<li>A <code>supports</code> query, like <code>supports = constructors</code>. A full list can be found on the <a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/struct.BackendAttrSupport.html"><code>BackendAttrSupport</code></a> type, but furthermore the pages on individual attributes will specifically list configuration options relevant to that attribute.</li>
<li><code>not(...)</code> containing a configuration specification</li>
<li><code>any(...)</code> containing one or more comma separated configuration specifications</li>
<li><code>all(...)</code> containing one or more comma separated configuration specifications</li>
</ul>
<p>So, for example, to  rename a type for everyone, one may use something like <code>#[diplomat::attr(*, rename = "FancyNewName")]</code> on the type. However if the rename is only intended for a select set of backends, one may do something like <code>#[diplomat::attr(any(js, cpp), rename = "FancyNewName")]</code>.</p>
<p>Similarly, if one wishes to only expose a type to backends that support iterators, one may do something like <code>#[diplomat::attr(not(supports = iterators), disable)]</code>.</p>
<p>A lot of attributes (basically all of them except for <code>rename</code> and <code>disable</code>) represent features that need not be present in all backends. For example, not every backend wishes to, or can, support iteration, or namespacing, or accessors. By default when an unsupported attribute is passed to a backend, Diplomat will error as a lint. However, this has the unfortunate effect of sprinkling the code with a lot of stuff that looks like <code>#[diplomat::attr(supports = iterators, iterator)]</code>.</p>
<p>To aid in that, <code>auto</code> can be used instead. <code>auto</code> is roughly equivalent to <code>supports = whichever attribute this is attempting to apply</code>.</p>
<h2 id="when-to-configure"><a class="header" href="#when-to-configure">When to configure</a></h2>
<p>Besides for reasons of differing backend support, Diplomat's attribute configuration is useful for providing a more idiomatic, tailored experience for individual languages. For example, in some languages (like C++) adding a field to a struct accepted as a parameter in a function would be a breaking change, but in languages like JS that change can be made without any breakage if the new field is nullable. In such a case, the appropriate mixing of language-specific renames can lead to a split v1/v2 API in C++ whilst JS gets a smoother experience with no need for versioning.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disabling-apis"><a class="header" href="#disabling-apis">Disabling APIs</a></h1>
<p>(Supported by all backends)</p>
<p>Any type or method can be "disabled" by applying the <code>disable</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    #[diplomat::attr(cpp, disable)]
    struct Foo;


    impl Foo {
        #[diplomat::attr(js, disable)]
        pub fn bar() {}
        pub fn baz() {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the class <code>Foo</code> will not show up in the C++ backend. It will in the JS backend, however it will not have the function <code>bar()</code>.</p>
<p>Currently enum variants cannot be disabled, however this is technically feasible for input-only enums and could be added if people request. It is also not possible to disable struct fields.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="renaming-apis"><a class="header" href="#renaming-apis">Renaming APIs</a></h1>
<p>(Supported by all backends)</p>
<p>Any type, method, field, or enum variant can be renamed with the <code>rename</code> attribute.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    #[diplomat::attr(cpp, rename = "Foo2")]
    struct Foo;

    impl Foo {
        #[diplomat::attr(js, rename = "barbar")]
        pub fn bar() {}
        pub fn baz() {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, C++ will see a class <code>Foo2</code> instead of <code>Foo</code>, and in JS the method <code>bar()</code> will be renamed to <code>barbar()</code>.</p>
<p>Note that some backends apply some of their own renames as well, which will be applied on top of the attribute rename. For example, the JS and Dart backends both turn <code>snake_case</code> into <code>camelCase</code> for better idiomaticity. Renaming to <code>bar_bar</code> would then produce <code>barBar()</code> in these backends.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespacing"><a class="header" href="#namespacing">Namespacing</a></h1>
<p>(Supported by <code>cpp</code>, queried with <code>supports = namespacing</code>)</p>
<p>This attribute can be applied on types and on bridge modules (applying to all types in the module).
It allows code to be organized under one or more namespaces.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
#[diplomat::attr(auto, namespace = "mylib")]
mod ffi {
    #[diplomat::opaque]
    struct Foo;

    #[diplomat::opaque]
    struct Bar;
}
<span class="boring">}</span></code></pre></pre>
<p>Here, in C++ <code>Foo</code> and <code>Bar</code> will both be available as <code>mylib::Foo</code> and <code>mylib::Bar</code>.</p>
<p>Nested namespaces are technically supported using things like <code>mylib::mymodule</code>, however they're not tested and support is brittle, so use at your own risk (<a href="https://github.com/rust-diplomat/diplomat/issues/591">#591</a>).</p>
<p>There is some discussion over separating the concept of a namespace and a library in <a href="https://github.com/rust-diplomat/diplomat/issues/589">#589</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructors"><a class="header" href="#constructors">Constructors</a></h1>
<p>(Supported by <code>dart</code>, queried with <code>supports = constructors</code>. Intended to be supported in <code>kotlin</code>, <code>js</code>, and <code>cpp</code>)</p>
<p>Methods that return <code>Self</code> can be marked as a constructor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct Foo;

    impl Foo {
        #[diplomat::attr(auto, constructor)]
        pub fn create() -&gt; Box&lt;Self&gt; {
            Box::new(Foo)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>and then instead of there being a regular <code>Foo::create()</code> method, <code>Foo</code> will now have a direct constructor <code>Foo()</code>.</p>
<p>Constructors can additionally be given names using <code>#[diplomat::attr(auto, named_constructor = "make")]</code>, for languages that support named constructors (<code>supports = named_constructors</code>).</p>
<p>Not all languages support fallible constructors, this can be queried with <code>supports = fallible_constructors</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators-and-iterables"><a class="header" href="#iterators-and-iterables">Iterators and iterables</a></h1>
<p>(Supported by <code>js</code>, <code>dart</code>, <code>kotlin</code>, queried with <code>supports = iterators</code> and <code>supports = iterables</code>)</p>
<p>Some languages support a first-class notion of "iterator", a type that can be looped over in a <code>for</code> loop, stepping through its values typically until they are exhausted.</p>
<p>Furthermore, some languages support a first-class notion of an "iterable": types like collections that can be asked to <em>produce</em> an iterator over their values which can be stepped through. Typically <code>for</code> loops will also accept iterables, and looping through an iterable involves producing and then looping through the associated iterator.</p>
<p>The distinction here is: iterators are mutated by iteration and often one-time use, iterables are not mutated and can be iterated over multiple times. Put in Rust terms, <code>Iterator</code> types are iterators, and <code>IntoIterator</code> types are iterables.</p>
<p>Diplomat supports marking types as such by using <code>iterator</code> and <code>iterable</code> on a specific <em>method</em> of the type.</p>
<h2 id="marking-a-type-as-an-iterator"><a class="header" href="#marking-a-type-as-an-iterator">Marking a type as an iterator</a></h2>
<p>To mark a type as an iterator, it should have a signature of <code>fn next(&amp;mut self) -&gt; Option&lt;...&gt;</code>. The method name may be anything, and it may take <code>self</code> by immutable reference instead, if needed (this is useful for situations where aliasing safety is needed, see <a href="https://github.com/rust-diplomat/diplomat/issues/225">#225</a> ).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct MyIterator&lt;'a&gt;(std::slice::Iter&lt;'a, u8&gt;);

    impl&lt;'a&gt; MyIterator&lt;'a&gt; {
        #[diplomat::attr(auto, iterator)]
        pub fn next(&amp;mut self) -&gt; Option&lt;u8&gt; {
            self.0.next().copied()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="marking-a-type-as-an-iterable"><a class="header" href="#marking-a-type-as-an-iterable">Marking a type as an iterable</a></h2>
<p>Marking a type as an iterable requires annotating it with <code>iterable</code>, and it just needs to be a method that takes <code>self</code> and returns a type that has a method marked as <code>iterator</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct MyVector(Vec&lt;u8&gt;);

    impl MyVector {
        #[diplomat::attr(auto, iterable)]
        pub fn iter&lt;'a&gt; (&amp;'a self) -&gt; Box&lt;MyIterator&lt;'a&gt;&gt; {
            Box::new(MyIterator(self.0.iter()))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getters-and-setters"><a class="header" href="#getters-and-setters">Getters and setters</a></h1>
<p>(Supported by <code>dart</code>, <code>js</code>, queried with <code>supports = accessors</code>)</p>
<h2 id="getters"><a class="header" href="#getters">Getters</a></h2>
<p>A method that returns a value (and takes no argument) can be marked as a getter. It may be fallible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct Foo {
        a: u8
    };

    impl Foo {
        #[diplomat::attr(auto, getter = "a")]
        pub fn get_a(&amp;self) -&gt; u8 {
            self.0
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>If the name is not provided, the method name is used<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>.</p>
<p>In languages that support accessors, instead of there being a <code>Foo::get_a()</code> method, people can use field access syntax on <code>Foo</code>-typed objects. For example, in JS, <code>foo.a</code> will work.</p>
<h2 id="setters"><a class="header" href="#setters">Setters</a></h2>
<p>A method that accepts a value can be marked as a setter. <code>self</code> need not be mutable, and the method may be fallible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct Foo {
        a: u8
    };

    impl Foo {
        #[diplomat::attr(auto, setter = "a")]
        pub fn set_a(&amp;mut self, a: u8)  {
            self.0 = a
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>If the name is not provided, the method name is used.</p>
<p>In languages that support accessors, instead of there being a <code>Foo::set_a()</code> method, people can use field access syntax on <code>Foo</code>-typed objects to set the value. For example, in JS, <code>foo.a = 1</code> will work.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>A potential future improvement is to use the method name but strip common prefixes like <code>get_</code> and <code>set_</code>, which would allow a getter and setter for the same field to coexist without requiring them have explicit names. <a href="#fr-1-1"></a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="indexing"><a class="header" href="#indexing">Indexing</a></h1>
<p>(Supported by <code>dart</code> and <code>cpp</code>, queried with <code>supports = indexing</code>)</p>
<p><code>[]</code> can be overloaded in languages that support it by applying an <code>indexer</code> attribute to a method that takes an integer argument and returns an <code>Option&lt;u8&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct Foo(Vec&lt;u8&gt;);

    impl Foo {
        #[diplomat::attr(auto, indexer)]
        pub fn get(&amp;self, idx: usize) -&gt; Option&lt;u8&gt; {
            self.0.get(idx).copied()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic-operator-overloads"><a class="header" href="#arithmetic-operator-overloads">Arithmetic operator overloads</a></h1>
<p>(Supported by and <code>cpp</code> and <code>nanobind</code>, queried with <code>supports = arithmetic</code>)</p>
<p><code>+-*/</code> and their in-place variants can be overloaded in languages that support it by applying an attribute to single-argument functions taking self. The Names are</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Name</th></tr></thead><tbody>
<tr><td>+</td><td>add</td></tr>
<tr><td>-</td><td>sub</td></tr>
<tr><td>*</td><td>div</td></tr>
<tr><td>/</td><td>mul</td></tr>
<tr><td>+=</td><td>add_assign</td></tr>
<tr><td>+=</td><td>sub_assign</td></tr>
<tr><td>+=</td><td>div_assign</td></tr>
<tr><td>+=</td><td>mul_assign</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct OpaqueInt(i32);

    impl OpaqueInt {
        #[diplomat::attr(auto, add)]
        pub fn add(&amp;self, v: i32) -&gt; Box&lt;OpaqueInt&gt; {
            Box::new(Self(self.0 + v))
        }

        #[diplomat::attr(auto, add_assign)]
        pub fn inplace_add(&amp;mut self, v: i32) {
            self.0 += v;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparators"><a class="header" href="#comparators">Comparators</a></h1>
<p>(Supported by <code>dart</code>, queried with <code>supports = comparators</code>. Intended to be supported in <code>cpp</code> and <code>kotlin</code>)</p>
<p>Some languages allow for overloading the <code>&lt;</code>/<code>&gt;</code>/<code>=</code>/etc operators, similar to Rust's <code>PartialOrd</code>.</p>
<p>To expose this over Diplomat, use the <code>comparison</code> attribute on a method that takes another <code>Self</code> parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    #[derive(Ord, PartialOrd, Eq, PartialEq)]
    struct Foo(u8);

    impl Foo {
        #[diplomat::attr(auto, comparison)]
        pub fn compare(&amp;self, other: &amp;Foo) -&gt; std::cmp::Ordering {
            self.cmp(other)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In Dart, this will provide an overloaded <code>==</code>, and <code>Foo</code> will implement <code>Comparable&lt;Foo&gt;</code>.</p>
<p>We currently do not but Diplomat would like to also support the ability to <em>just</em> overload <code>==</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stringifiers"><a class="header" href="#stringifiers">Stringifiers</a></h1>
<p>(Supported by <code>dart</code>, queried with <code>supports = stringifiers</code>. Intended to be supported in <code>js</code> and <code>kotlin</code>)</p>
<p>Some languages have a designated way to provide a method for converting a type to a string.</p>
<p>The <code>stringifier</code>  attribute can be applied to such a method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct Foo;

    impl Foo {
        #[diplomat::attr(auto, stringifier)]
        pub fn dump(&amp;self, out: &amp;mut DiplomatWrite) {
            ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In Dart, this will generate a <code>toString()</code> method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notes-on-diplomat-and-safety"><a class="header" href="#notes-on-diplomat-and-safety">Notes on Diplomat and safety</a></h1>
<p>Overall, Diplomat is intended to provide safe FFI. However, there are some caveats around the current state of Diplomat's safety.</p>
<h2 id="the-safety-of-the-bridge-crate-when-called-from-rust"><a class="header" href="#the-safety-of-the-bridge-crate-when-called-from-rust">The safety of the bridge crate when called from Rust</a></h2>
<p>Diplomat's <code>extern "C"</code> functions are generated in a "bridge crate" that contains "bridge modules" tagged with <code>#[diplomat::bridge]</code>. This generated code is not designed with Rust as a primary client, rather, it is designed to be used from C.</p>
<p>As such, it may be possible to trigger unsoundness by directly calling these <code>extern "C"</code> APIs from Rust. Work shoring this up is welcome.</p>
<h2 id="aliasing-safety"><a class="header" href="#aliasing-safety">Aliasing safety</a></h2>
<p>Primary issue: <a href="https://github.com/rust-diplomat/diplomat/issues/225">#225</a></p>
<p>In Rust, it is undefined behavior to have any additional references (<code>&amp;</code> or <code>&amp;mut</code>) to some data whilst there is an active <code>&amp;mut T</code> reference to it.</p>
<p>Diplomat currently lets you do the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {

    #[diplomat::opaque]
    struct Foo(u8);

    #[diplomat::opaque]
    struct Bar(Foo);


    impl Bar {
        pub fn change_foo_number(&amp;mut self, num: u8) {
            self.0.0 = num;
        }
        pub fn get_foo(&amp;self) -&gt; &amp;Foo {
            &amp;self.0
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>Calling <code>change_foo_number()</code> while a reference from <code>get_foo()</code> is active could be UB, or cause thread safety issues in multithreaded code.</p>
<p>Diplomat has <a href="https://github.com/rust-diplomat/diplomat/issues/225">plans</a> on how to fix this, but until this is fixed, it can be avoided by doing the following:</p>
<ul>
<li>Limit the number of mutable methods you expose (use <code>RefCell</code> where needed)</li>
<li>If you wish to expose a mutable method, ensure that:
<ul>
<li>The type cannot ever be obtained as an <code>&amp;T</code> or <code>&amp;mut T</code> from some other type</li>
<li>The type does not have any methods that produce an <code>&amp;U</code> or <code>&amp;mut U</code>, where <code>U</code> is an opaque type or slice that borrows from things that the method intends to mutate.</li>
</ul>
</li>
</ul>
<p>As long as you're careful, this should not be an issue. ICU4X tends to not need much in the way of mutation and is so far safe from this.</p>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread safety</a></h2>
<p>Primary issue: <a href="https://github.com/rust-diplomat/diplomat/issues/533">#533</a></p>
<p>So far ICU4X has mostly been targeting languages where thread safety is locked down by thread isolation (Dart, JS), or where thread safety is a matter of documentation convention (C++), so it has not yet needed to think deeply about this. However, other users of Diplomat may.</p>
<p>Specific backends may choose their own route as to how they apply and enforce thread safety. Diplomat may over time add some annotation system to help with this. Limiting mutation and using <code>RwLock</code>/<code>Mutex</code> can help here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-set-up-a-minimal-backend"><a class="header" href="#how-to-set-up-a-minimal-backend">How to Set up a Minimal Backend</a></h1>
<p>How to create a backend is quite language dependent, and what is easier in one
may be harder in another. Below we will start setting up a simple backend. We'll
show you how to set up a test in diplomat so you can start generating code quickly.
Then we give you a template for a simple dynamic library that you can then link
to your host language. Finally we provide a suggested checklist for your backend.
It is not automatically generated so when in doubt look at diplomat's <a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/index.html">HIR</a></p>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>project structure</strong>: You will need need to test your generated code so you should
first set up a host language project. It should have all dependencies to be able to interface
with native code (or WASM).</li>
</ul>
<h2 id="setting-up-basic-code-generation-in-a-test"><a class="header" href="#setting-up-basic-code-generation-in-a-test">Setting up Basic Code Generation in a Test</a></h2>
<p>Your backend should iterate over all <a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/enum.TypeDef.html"><code>TypeDefs</code></a>
and generate the required code for these. To do that we start with an
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/ast/struct.File.html"><code>ast::File</code></a>, which can
then be parsed into a <a href="https://docs.rs/diplomat_core/latest/diplomat_core/struct.Env.html"><code>Env</code></a>
using the
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/ast/struct.File.html#method.all_types"><code>all_types</code></a>
method. Then we can create the
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/struct.TypeContext.html"><code>TypeContext</code></a>
which is generated using the
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/struct.TypeContext.html#method.from_ast"><code>from_ast</code></a>
method. You will also need an
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/trait.AttributeValidator.html"><code>AttributeValidator</code></a>,
but should probably start with the simple
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/struct.BasicAttributeValidator.html"><code>BasicAttributeValidator</code></a>.</p>
<p>We will now build an example by way of a test. A good starting point is to create a test for
generating a simple opaque struct without any methods. Your backend should go in the tool crate:
create a module <code>tool/src/{backend}/mod.rs</code>  (make sure you add a line <code>pub mod backend;</code> to
<code>tool/src/lib.rs</code>). Add the following to it</p>
<pre><code class="language-rs">use diplomat_core::hir::{OpaqueDef, TypeContext, TypeId};

fn gen_opaque_def(ctx: &amp;TypeContext, type_id: TypeId, opaque_path: &amp;OpaqueDef) -&gt; String {
    "We'll get to it".into()
}

#[cfg(test)]
mod test {
    use diplomat_core::{
        ast::{self},
        hir::{self, TypeDef},
    };
    use quote::quote;

    #[test]
    fn test_opaque_gen() {
        let tokens = quote! {
            #[diplomat::bridge]
            mod ffi {

                #[diplomat::opaque]
                struct OpaqueStruct;

            }
        };
        let item = syn::parse2::&lt;syn::File&gt;(tokens).expect("failed to parse item ");

        let diplomat_file = ast::File::from(&amp;item);
        let env = diplomat_file.all_types();
        let attr_validator = hir::BasicAttributeValidator::new("my_backend_test");

        let context = match hir::TypeContext::from_ast(&amp;env, attr_validator) {
            Ok(context) =&gt; context,
            Err(e) =&gt; {
                for (_cx, err) in e {
                    eprintln!("Lowering error: {}", err);
                }
                panic!("Failed to create context")
            }
        };

        let (type_id, opaque_def) = match context
            .all_types()
            .next()
            .expect("Failed to generate first opaque def")
        {
            (type_id, TypeDef::Opaque(opaque_def)) =&gt; (type_id, opaque_def),
            _ =&gt; panic!("Failed to find opaque type from AST"),
        };

        let generated = super::gen_opaque_def(&amp;context, type_id, opaque_def);

        insta::assert_snapshot!(generated)
    }
}
</code></pre>
<p>You can now run</p>
<pre><code class="language-sh">cargo test -p diplomat-tool -- backend::test --nocapture
</code></pre>
<p>You should also have a generated snapshot <code>diplomat_tool__backend__test__opaque_gen.snap.new</code>
which you can use to pick up your generated code.</p>
<h2 id="how-to-generate-the-library"><a class="header" href="#how-to-generate-the-library">How to Generate the Library</a></h2>
<p>Now to actually test native methods you will need to create some kind of library, be it static, dynamic, or
even WASM. In the following we will be creating a dynamically linked library.</p>
<p>You should set up a separate rust project next to your diplomat fork e.g. <code>mybackendtest</code></p>
<pre><code class="language-sh">cargo new --lib mybackendtest
</code></pre>
<p>with the following Cargo.toml</p>
<pre><code class="language-toml">[package]
name = "mybackendtest"
version = "0.1.0"
edition = "2021"

[lib]
crate_type = ["cdylib"]
name = "mybackendtest"

[dependencies]
diplomat = {path = "../diplomat/macro"}
diplomat-runtime = {path = "../diplomat/runtime"}
</code></pre>
<p>Because you are using path dependencies, it is important that your library project be in
the same directory as your fork of diplomat</p>
<p>Copy the following into your lib.rs</p>
<pre><code class="language-rs">#[diplomat::bridge]
mod ffi {

    #[diplomat::opaque]
    struct OpaqueStruct;

    impl OpaqueStruct {
        pub fn add_two(i: i32) -&gt; i32 {
            i + 2
        }
    }
}

</code></pre>
<p>Note it is very important that the method be marked <code>pub</code> otherwise diplomat will ignore it.
Now you can run</p>
<pre><code class="language-sh">cargo build
</code></pre>
<p>to create a debug artifact in <code>target/debug/libmybackendtest.dylib</code></p>
<h2 id="getting-access-to-your-native-method"><a class="header" href="#getting-access-to-your-native-method">Getting Access to your Native Method</a></h2>
<p>Now we can add code that will iterate over all of the methods of the opaque struct.
First, copy the impl block for <code>OpaqueStruct</code> into the test code underneath the <code>OpaqueStruct</code>.
Next, update your the code for <code>gen_opaque_def</code> to the following which will generate the native
symbol for your new impl method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::c2::CFormatter;

fn gen_opaque_def(ctx: &amp;TypeContext, type_id: TypeId, opaque_path: &amp;OpaqueDef) -&gt; String {
    let c_formatter = CFormatter::new(ctx);

    opaque_def
        .methods
        .iter()
        .map(|method| c_formatter.fmt_method_name(type_id, method))
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .join("\n")
}
<span class="boring">}</span></code></pre></pre>
<p>Now your snapshot should have the following contents</p>
<pre><code>---
source: tool/src/backend/mod.rs
assertion_line: 67
expression: generated
---
OpaqueStruct_add_two
</code></pre>
<p>where <code>OpaqueStruct_add_two</code> is the native symbol for your method. It has a simple signature <code>i32 -&gt; i32</code>,
so now you have a dynamic library and a symbol to load from it that you can start building. Now it is up
to you to figure how to integrate these into your host language project skeleton.</p>
<h2 id="minimal-backend"><a class="header" href="#minimal-backend">Minimal Backend</a></h2>
<p>You should now work on building a minimal backend that can generate opaque type definitions
with methods that only accept and return <a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/enum.PrimitiveType.html"><strong>primitive types</strong></a>.</p>
<p>You will need to update <code>tool/src/lib.rs</code> to add handling for your backend.</p>
<p>Once you have the basics of a backend you can add attribute handling. The best way to do this is to check the existing backends
e.g. <a href="https://github.com/rust-diplomat/diplomat/blob/b3a8702f6736dbd6e667638ca0025b8f8cd1509f/tool/src/lib.rs#L95">dart</a>(Note: git permalink may be out of date).
The most important is to ignore disabled types and methods, as then you can take advantage of diplomat's feature tests
and start building progressively.</p>
<h2 id="feature-tests"><a class="header" href="#feature-tests">Feature Tests</a></h2>
<p>Diplomat already includes feature tests that you can disable with <code>#[diplomat::attrs(disable, {backend})]</code>.
where <code>{backend}</code> refers to your new backend. As you add functionality to your backend you
can progressively enable the types and methods for your backend. This way you can iterate with
working examples. These are called via <a href="https://sagiegurari.github.io/cargo-make/">cargo-make</a>
e.g</p>
<pre><code class="language-sh">cargo make gen-dart-feature
</code></pre>
<p>You can look at <code>Makefile.toml</code> to see how tasks are defined. Most of the generative tasks make use of this
<a href="https://github.com/rust-diplomat/diplomat/blob/b3a8702f6736dbd6e667638ca0025b8f8cd1509f/support/functions.ds#L1">duckscript function</a>
(<a href="https://sagiegurari.github.io/duckscript/">Duckscript</a> is a simple scripting language)</p>
<h2 id="backend-checklist"><a class="header" href="#backend-checklist">Backend Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/enum.PrimitiveType.html"><strong>primitive types</strong></a>: This will be the most basic piece of the backend, and you will want
to implement them early in order to test your ability to correctly call methods.</li>
<li><input disabled="" type="checkbox"/>
<a href=""><strong>opaque types</strong></a>:
<ul>
<li><input disabled="" type="checkbox"/>
basic definiton</li>
<li><input disabled="" type="checkbox"/>
return a boxed opaque. This needs to be cleaned in managed languages.
You can use the autogenerated <code>{OpaqueName}_destroy({OpaqueName}*)</code> native method to clean up
the memory of the associated opaque.</li>
<li><input disabled="" type="checkbox"/>
as self parameter</li>
<li><input disabled="" type="checkbox"/>
as another parameter</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/0.7.0/diplomat_core/hir/struct.StructDef.html"><strong>structs</strong></a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/0.7.0/diplomat_core/hir/struct.EnumDef.html"><strong>enums</strong></a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/0.7.0/diplomat_core/hir/enum.SuccessType.html#variant.Writeable"><strong>writeable</strong></a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/0.7.0/diplomat_core/hir/enum.Slice.html"><strong>slices</strong></a>
<ul>
<li><input disabled="" type="checkbox"/>
primitive slices</li>
<li><input disabled="" type="checkbox"/>
str slices</li>
<li><input disabled="" type="checkbox"/>
owned slices</li>
<li><input disabled="" type="checkbox"/>
slices of strings</li>
<li><input disabled="" type="checkbox"/>
strings</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
borrows. This is probably one of the trickiest things, as you need to ensure that managed objects don't get
cleaned up if something depends on them.
<ul>
<li><input disabled="" type="checkbox"/>
borrows of parameters</li>
<li><input disabled="" type="checkbox"/>
in struct fields</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
nullables, i.e. returning option types.</li>
<li><input disabled="" type="checkbox"/>
fallibles, i.e. returning result types. The resulting native type will be a discriminated union.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo_gen"><a class="header" href="#demo_gen">demo_gen</a></h1>
<h2 id="what-is-demo_gen"><a class="header" href="#what-is-demo_gen">What is demo_gen?</a></h2>
<p>demo_gen is a backend for creating demonstration webpages automatically from Diplomat FFI definitions. These webpages are meant to showcase the capabilities of your library.</p>
<p>You can view the tracking issue for the demo_gen backend <a href="https://github.com/rust-diplomat/diplomat/issues/604">here</a>.</p>
<p>If you're interested in the design behind demo_gen, we have a <a href="https://github.com/rust-diplomat/diplomat/blob/main/docs/demo_gen.md">design document</a> viewable on the Diplomat repository.</p>
<h2 id="why-do-i-want-to-use-demo_gen"><a class="header" href="#why-do-i-want-to-use-demo_gen">Why do I want to use demo_gen?</a></h2>
<p>The current big-name use case for demo_gen is the ICU4X internationalization library. ICU4X has a wide breadth of functions that can be somewhat hard to grasp if you're not already using the library heavily. demo_gen is a quick way</p>
<p>You can view the ICU4X demo_gen results <a href="https://ambiguous.name/icu4x/">here</a> for a full demonstration of what demo_gen is currently capable.</p>
<p>If you're interested in trying demo_gen yourself, hop on to the <a href="demo_gen/./quickstart.html">Quickstart</a> page to get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>Demo Gen takes a bit of configuration if you don't already have your own Diplomat library set up.</p>
<p>For that reason, we have a <a href="https://github.com/rust-diplomat/demo-gen-quickstart">quickstart repository</a>. You can also follow along in your own library if you'd like.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>You'll need to clone <a href="https://github.com/rust-diplomat/demo-gen-quickstart">the repository</a>.</p>
<p>You'll need to have Rust, Cargo, and the <code>wasm32-unknown-unknown</code> target installed:</p>
<pre><code class="language-sh">rustup target add wasm32-unknown-unknown
</code></pre>
<p>You'll also need <code>Node</code> and <code>npm</code> <a href="https://nodejs.org/en/download/package-manager">installed</a>, as Diplomat generates JS code in modules that is easier for Node to parse as a package.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>You just need to run (in the repository folder):</p>
<pre><code class="language-sh">cargo build -p adder_bindings --target wasm32-unknown-unknown
cargo run -p generator
cp target/wasm32-unknown-unknown/debug/adder_bindings.wasm adder_bindings/demo
</code></pre>
<p>You'll notice the <code>demo</code> folder now has a <code>demo_gen</code> folder, which is full of JS and rendering files. We can view our results in an HTTP server:</p>
<pre><code class="language-sh">npm -C adder_bindings/demo install
npm -C adder_bindings/demo run start
</code></pre>
<p>If you open the server, you should see a webpage listing <code>AddResult.getAddStr</code> with a link. If you click the link, you should see something like:</p>
<p><img src="demo_gen/images/demo_output.png" alt="A search bar for the web server, with the added URL /demo_gen/rendering/template.html?func=AddResult.getAddStr. Displayed on the webpage is &quot;AddResult.getAddStr&quot; in large text. Below are two inputs: one labelled &quot;left&quot; that has a value of 1, and one labelled &quot;right&quot; that has a value of 2. Below is a submit button. There is output below the button, with the label &quot;Output&quot; and a value of 3." /></p>
<p>And that's it! Let's talk about what each step means.</p>
<h1 id="what-we-just-accomplished"><a class="header" href="#what-we-just-accomplished">What We Just Accomplished</a></h1>
<p>When you clone the repository, you'll notice three packages.</p>
<h2 id="the-library"><a class="header" href="#the-library">The Library</a></h2>
<p><code>basic_adder</code> is our Rust library that we want to make examples of. It only has one function:</p>
<pre><code class="language-rs">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}
</code></pre>
<p>Everything else we build will be based on this.</p>
<h2 id="the-bindings"><a class="header" href="#the-bindings">The Bindings</a></h2>
<p><code>adder_bindings</code> is our <a href="demo_gen/../basics.html">Diplomat bridge</a>. When we want to make our library accessible in other languages, we need to run <code>diplomat-tool</code> on these bindings.</p>
<p>We build these bundings with</p>
<pre><code class="language-sh">cargo build -p adder_bindings --target wasm32-unknown-unknown
</code></pre>
<p><code>--target wasm32-unknown-unknown</code> tells <code>cargo</code> to build a <code>.wasm</code> file.</p>
<p>For more on how you can explicitly configure your bindings to work better in demos, see <a href="demo_gen/attributes.html">the chapter on attributes</a>.</p>
<h2 id="the-generator"><a class="header" href="#the-generator">The Generator</a></h2>
<p><code>generator</code> is our wrapper for calling <code>diplomat-tool</code>. demo_gen is still in progress, and so we need a wayt to use the latest version of <code>diplomat-tool</code> to use this experimental backend. <code>generator</code> may be removed in future versions of this tutorial.</p>
<p>We run the generator with</p>
<pre><code class="language-sh">cargo run -p generator
</code></pre>
<p>And it performs the equivalent of:</p>
<pre><code class="language-sh">diplomat-tool demo_gen adder_bindings/demo/demo_gen --entry adder_bindings/src/lib.rs
</code></pre>
<p>demo_gen will automatically generate JS bindings by default, along with a bunch of other files to help you get started as easily as possible. If you have JS bindings elsewhere, or a different file structure from the Quickstart repository, you can configure how demo_gen works with a library config file. See <a href="demo_gen/markup.html">the section on markup generation for more</a>.</p>
<h2 id="the-web-demo"><a class="header" href="#the-web-demo">The Web Demo</a></h2>
<p>demo_gen is designed to work with most Diplomat libraries with minimal configuration. However, we currently don't provide <em>everything</em> that you'll need to instantly see a demo</p>
<p>The minimum requirement is at least a web server to load JS modules.</p>
<p>This is why we have you run</p>
<pre><code class="language-sh">npm -C adder_bindings/demo install
npm -C adder_bindings/demo run start
</code></pre>
<p>See the chapter on <a href="demo_gen/./renderer.html">the renderer</a> for more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>demo_gen does a lot in its attempt to automagically generate demonstrations for you. Sometimes however, hands on configuration is required.</p>
<p>Find below a list of the attributes that demo_gen supports.</p>
<h2 id="diplomatattr"><a class="header" href="#diplomatattr">#[diplomat::attr]</a></h2>
<p>demo_gen supports all attributes listed in the <a href="demo_gen/../attrs.html">attrs chapter</a>. You mostly will want to use the <code>disable</code> attribute, to disable any functions that you may not want to include in output.</p>
<p>Because demo_gen is so heavily based on the JS backend, any <code>#[diplomat::attr]</code>s that apply to the JS backend will also apply to the demo_gen backend. So for example, any methods disabled in the JS backend will also be disabled in demo_gen's output.</p>
<h2 id="diplomatdemo"><a class="header" href="#diplomatdemo">#[diplomat::demo]</a></h2>
<p>This is the core attribute that demo_gen looks for in configuring its output. There are a few supported attributes currently:</p>
<h3 id="diplomatdemogenerate"><a class="header" href="#diplomatdemogenerate">#[diplomat::demo(generate)]</a></h3>
<p>Used in explicit generation of output. See <a href="demo_gen/./markup.html">markup</a> for more.</p>
<h3 id="diplomatdemodefault_constructor"><a class="header" href="#diplomatdemodefault_constructor">#[diplomat::demo(default_constructor)]</a></h3>
<p>demo_gen will throw errors for any Opaque types that do not have a method labelled with this attribute. demo_gen also looks for any Opaque methods labelled with <code>#[diplomat::attr(auto, constructor)]</code> as an alternative.</p>
<p>You should label each Opaque in your FFI definition with a <code>default_constructor</code> attribute, where the method is one you expect most users to call regularly when trying to create the Opaque in question. If your Opaque does not have an associated constructor method in its <code>impl</code> block, you should consider disabling functions (as this sort of behavior is too advanced for demo_gen to parse correctly).</p>
<p>For reasons on why demo_gen requires explicit labelling of Opaque constructors, see <a href="https://github.com/rust-diplomat/diplomat/blob/main/docs/demo_gen.md">the demo_gen design doc</a>.</p>
<h3 id="diplomatdemoexternal"><a class="header" href="#diplomatdemoexternal">#[diplomat::demo(external)]</a></h3>
<p>Can be used above a parameter, struct field, or Opaque type.</p>
<p>It represents any input that you want to specify custom behavior for in the <a href="demo_gen/./renderer.html">rendering</a> Javascript.</p>
<p>For example: In ICU4X, we have a <code>DataProvider</code> Opaque type that must be compiled ahead of time, and so we flag it as an external type:</p>
<pre><code class="language-rs">#[diplomat::bridge]
mod ffi {
	#[diplomat::opaque]
	#[diplomat::demo(external)]
	pub struct DataProvider;
}
</code></pre>
<p>We then override the <a href="demo_gen/renderer.html#runtimemjs">default renderer's runtime.mjs</a> file to provide the compiled <code>DataProvider</code> when it is requested.</p>
<h3 id="diplomatdemoinput"><a class="header" href="#diplomatdemoinput">#[diplomat::demo(input(...))]</a></h3>
<p>For configuring user input to your demos. <code>input(...)</code> takes in a comma separated list of values.</p>
<p>May be used on parameters or struct fields to configure specific properties passed to the <a href="demo_gen/renderer.html">renderer</a>.</p>
<p>Here are some valid <code>input</code> values:</p>
<ul>
<li><code>input(label = "Label Here")</code>. Changes the label a given function parameter will have in the output.</li>
</ul>
<h4 id="input-example"><a class="header" href="#input-example">Input Example</a></h4>
<p>If we modify our <a href="demo_gen/quickstart.html">quickstart</a> example, we can add <code>#[diplomat::demo(input(...))]</code> labels to the function parameters:</p>
<pre><code class="language-rs">#[diplomat::bridge]
mod ffi {
    use std::fmt::Write;

	#[diplomat::opaque]
	#[diplomat::rust_link(basic_adder, Mod)]
	pub struct AddResult;

	impl AddResult {
		pub fn get_add_str(
			#[diplomat::demo(input(label = "x"))]
			left : u32, 
			#[diplomat::demo(input(label = "y"))]
			right : u32, write: &amp;mut DiplomatWrite) {
			write.write_str(&amp;format!("{}", basic_adder::add(left, right))).unwrap();
			write.flush();
		}
	}
}
</code></pre>
<p>Which creates the following HTML output:</p>
<p><img src="demo_gen/images/demo_output_renamed.png" alt="&quot;AddResult.getAddStr&quot; in large text. Below are two inputs: one labelled &quot;x&quot; that has a value of 10, and one labelled &quot;y&quot; that has a value of 2. Below is a submit button. There is output below the button, with the label &quot;Output&quot; and a value of 12." /></p>
<h3 id="diplomatdemocustom_func"><a class="header" href="#diplomatdemocustom_func">#[diplomat::demo(custom_func="...")]</a></h3>
<p>See <a href="demo_gen/./custom_functions.html">Making Custom Functions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-markup"><a class="header" href="#configuring-markup">Configuring Markup</a></h1>
<p>Through <a href="demo_gen/../config.html">Diplomat's configuration interfaces</a>, you can customize some of demo_gen's output. Here's a sample .toml file for configuration (with comments for clarity):</p>
<pre><code class="language-toml">[demo-gen]
# If false, demo_gen will automatically search all methods for functions it can generate demonstration JS for.
# If true, demo_gen will look for any methods explicitly flagged with #[diplomat::demo(generate)] to perform generation.
explicit-generation=true # default = false (bool)

# This removes the rendering/ folder.
hide-default-renderer=true # default = false (bool)

# Adjusts all imports that demo_gen creates to a specific module. Setting this will not generate the js/ folder.
#
# So for instance, this setting will adjust imports to: `import { type } from "icu4x";
module-name="icu4x" # (string)

# Adjusts all imports that demo_gen creates to a relative path where Diplomat JS output should be. Setting this will not generate the js/ folder.
# 
# Setting this will adjust imports to: `import {type} from "../js/folder/here/index.mjs";
# 
# Intended to be a mutually exclusive setting with module_name, although you can set both simultaneously to import modules from a relative path. 
relative-js-path="../js/folder/here" # (string)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-the-default-renderer"><a class="header" href="#configuring-the-default-renderer">Configuring the Default Renderer</a></h1>
<p>demo_gen comes bundled with an HTML renderer to make getting started with creating demo_gen output to be as fast as possible. The default renderer is also designed to be highly customizable for your own preferences or front ends.</p>
<p>The front end renderer uses <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components">Web Components</a>, which are natively supported by most browsers. For this reason, it should be very portable into other front end systems like Svelte or React. However, if you're dead set on a solution that works even <em>better</em> for your front end of choice, you should read <a href="demo_gen/./custom_renderer.html">making your own renderer</a>.</p>
<p>For more on how the default renderer works, you can read our <a href="https://github.com/rust-diplomat/diplomat/blob/main/docs/design_doc.md">design doc</a>.</p>
<p>Regardless, let's discuss some ways you can customize the default renderer to your liking.</p>
<h2 id="templatehtml"><a class="header" href="#templatehtml">template.html</a></h2>
<p><code>rendering/template.html</code> represents a list of templates that demo_gen's default renderer will use</p>
<p>demo_gen will automatically generate <code>template.html</code> in the rendering folder. There is nothing that ties <code>template.html</code> to this folder specifically however; you can copy, modify, and link to a changed <code>template.html</code> file for custom HTML, JS, and CSS.</p>
<p>For instance, this is one template we've overridden in the ICU4X repo to take advantage of Bootstrap:</p>
<pre><code class="language-html">&lt;template id="terminus"&gt;
&lt;link rel="stylesheet" href="dist/index.css"/&gt;
&lt;div class="vstack gap-2"&gt;
	&lt;h1&gt;&lt;slot name="func-name"&gt;&lt;/slot&gt;&lt;/h1&gt;
	&lt;slot name="parameters"&gt;&lt;/slot&gt;
	&lt;button type="submit" class="btn btn-primary" data-submit&gt;Submit&lt;/button&gt;
	&lt;div class="card"&gt;
		&lt;div class="card-header"&gt;Output&lt;/div&gt;
		&lt;div class="card-body"&gt;
			&lt;p&gt;&lt;slot name="output"&gt;Output Shown Here&lt;/slot&gt;&lt;/p&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>For <code>&lt;template&gt;</code> tags, we hook into events by looking for <code>data-*</code> attributes, which have some of the following properties:</p>
<ul>
<li><code>data-submit</code> tells the attached element to await a press before attempting to run demo_gen code (only works for the <code>#terminus</code> tag).</li>
<li><code>data-oninput</code> tells the attached element to listen for the <code>oninput</code> event and save the user's input on this element for submission.</li>
</ul>
<p>If you're on the <a href="demo_gen/quickstart.html">quickstart</a> repository, you might try copying <code>template.html</code> out of the rendering folder and modifying it yourself to include your own stylesheets.</p>
<blockquote>
<p>[!NOTE]
Because the renderer uses the Web Components API, stylesheets need to be linked inside of each <code>&lt;template&gt;</code> tag.</p>
</blockquote>
<h2 id="runtimemjs"><a class="header" href="#runtimemjs">runtime.mjs</a></h2>
<p>This is simply a wrapper for the underlying <code>rendering/rendering.mjs</code>, which contains most of the logic for taking <code>&lt;template&gt;</code> tags and transforming them into</p>
<p>The expected end result of <code>runtime.mjs</code> is to create a <code>TerminusRender</code> object from <code>rendering.mjs</code>, and append it to the HTML.</p>
<p>If you are interested in overriding the underlying Javascript more thoroughly, reading the documentation <a href="demo_gen/custom_renderer.html">on writing your own custom renderer</a> is recommended. Otherwise, you will mostly be interested in overwriting the <code>evaluateExternal</code> parameter, which looks something like this:</p>
<pre><code class="language-js">(param, updateParamEvent) =&gt; {
	console.error(`Unrecognized parameter type ${param}`);
}
</code></pre>
<p>If you've flagged anything with the <a href="demo_gen/attributes.html#diplomatdemoexternal">external</a> attribute, you can check for parameters that Diplomat cannot evaluate on its own and provide these yourself with the <code>updateParamEvent(updatedParamValue)</code> callback, containing the value of the parameter that is required.</p>
<blockquote>
<p>[!TIP]
<code>evaluateExternal</code> is only called once on creation, so if you're planning on updating a param more than once, you should save a dictionary of <code>updateParamEvent</code> callbacks somewhere for future reference.</p>
</blockquote>
<p>For example, in the ICU4X demo, we look for the DataProvider parameter and provide it from a compiled set of data:</p>
<pre><code class="language-js">let dataProvider = DataProvider.compiled();
let evaluateExternal = (param, updateParamEvent) =&gt; {
    if (parameter.type === "DataProvider") {
        updateParamEvent(dataProvider);
    } else {
        console.error(`Unrecognized parameter type ${param}`);
    }
};
</code></pre>
<h2 id="indexhtml"><a class="header" href="#indexhtml">index.html</a></h2>
<p>demo_gen currently doesn't provide an <code>index.html</code> file for you, as even with the default renderer your file structure can vary wildly. It is up to the user to provide their own additional <code>.html</code> files.</p>
<p>If you're looking to get into output right away: you can access any function from the default renderer by opening <code>template.html</code> from your webserver with the URL <code>/renderer/template.html?func=TypeName.functionName</code>.</p>
<p>Here's the current script that <a href="demo_gen/quickstart.html">the quickstart</a> has to list all possible function names:</p>
<pre><code class="language-js">import { RenderInfo } from "./demo_gen/index.mjs";

Object.values(RenderInfo.termini).forEach((t) =&gt; {
	let a = document.createElement("li");
	a.innerHTML = `&lt;a href="demo_gen/rendering/template.html?func=${t.funcName}"&gt;${t.funcName}&lt;/a&gt;`;
	document.getElementById("links").appendChild(a);
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-your-own-renderer"><a class="header" href="#making-your-own-renderer">Making Your Own Renderer</a></h1>
<p>Inside of <code>index.mjs</code>, demo_gen outputs an object called <code>RenderInfo</code> that points to all the functions demo_gen has created for the purposes of demonstration.</p>
<p><code>RenderInfo</code> gives you the function to call directly, as well as the required parameters needed for each function in order.</p>
<p>This is meant to slot in to almost any Javascript solution with ease, but if there's an issue with <code>RenderInfo</code>s setup that is not quite compatible with your solution, please <a href="https://github.com/rust-diplomat/diplomat/issues/new?labels=B-demo_gen">open an issue</a>.</p>
<p>The exact structure of <code>RenderInfo</code> is available in the demo_gen <a href="https://github.com/rust-diplomat/diplomat/blob/main/docs/demo_gen.md#step-two-constructing-renderinfo">design docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-custom-functions"><a class="header" href="#making-custom-functions">Making Custom Functions</a></h1>
<h2 id="what-is-a-custom-function"><a class="header" href="#what-is-a-custom-function">What is a custom function?</a></h2>
<p>demo_gen tends towards automagical configuration. demo_gen will do its best to take Rust functions and convert them into JS output.</p>
<p>But there arise situations where we want to create our own custom Javascript functions to demonstrate our library's capabilities to the user, then add them to demo_gen's output. This may be the case if you want to demonstrate functionality that is more involved than demo_gen's automagical work.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Let's look at the <a href="demo_gen/quickstart.html">quickstart</a> repository for an example.</p>
<p>We only have one function exposed: <code>get_add_str(left : u32, right: u32)</code>.</p>
<p>What if we have variables <code>a</code>, <code>b</code>, and <code>c</code>, and we want to show the user the results of calling:</p>
<p><code>get_add_str(a, b)</code> and <code>get_add_str(b, c)</code>?</p>
<p>We can do this without adding a new binding, through the use of a custom Javascript function.</p>
<h2 id="diplomatdemocustom_func-1"><a class="header" href="#diplomatdemocustom_func-1">#[diplomat::demo(custom_func="...")]</a></h2>
<p><code>#[diplomat::demo(custom_func="filename.mjs")]</code> can be added above any <code>struct</code> definition. demo_gen will search for files relative to <code>lib.rs</code>, and add the contents of <code>filename.mjs</code> to its output.</p>
<p>Then demo_gen will import the default export of <code>filename.mjs</code>, and append it to the list of <a href="https://github.com/rust-diplomat/diplomat/blob/main/docs/demo_gen.md#step-two-constructing-renderinfo">RenderInfo</a> termini.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>So, first we create a file called <code>adder_custom.mjs</code> in the same folder as <code>adder_bindings/src/lib.rs</code>:</p>
<pre><code class="language-js">// adder_bindings/src/adder_custom.mjs
import { lib } from "./index.mjs";
export default {
    "AddThreeVariables": {
        func: (a, b, c) =&gt; { return lib.AddResult.getAddStr(a, b) + " and " + lib.AddResult.getAddStr(b, c); },
        funcName: "Add a + b, b + c",
        parameters: [
            {
                name: "a",
                type: "number"
            },
            {
                name: "b",
                type: "number"
            },
            {
                name: "c",
                type: "number"
            }
        ]
    }
}
</code></pre>
<p>Then we make sure to link <code>adder_custom.mjs</code> in <code>lib.rs</code>:</p>
<pre><code class="language-rs">// adder_bindings/src/lib.rs
#[diplomat::bridge]
mod ffi {
    use std::fmt::Write;

	#[diplomat::opaque]
	#[diplomat::rust_link(basic_adder, Mod)]
    #[diplomat::demo(custom_func="adder_custom.mjs")]
	pub struct AddResult;

	impl AddResult {
		pub fn get_add_str(left : u32, right : u32, write: &amp;mut DiplomatWrite) {
			write.write_str(&amp;format!("{}", basic_adder::add(left, right))).unwrap();
			write.flush();
		}
	}
}
</code></pre>
<p>And our exported object is then added to <code>RenderInfo</code>s list of render termini, and is evaluated by the renderer accordingly!</p>
<p>If you <a href="https://rust-diplomat.github.io/diplomat/demo_gen/quickstart.html#getting-started">regenerate the bindings and start the web server</a>, you should see <code>Add a + b, b + c</code> in the list of functions.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
